import pandas as pd
import numpy as np
import plotly.express as px
import dash_bootstrap_components as dbc
import plotly.graph_objects as go
import dash
from dash import dcc, html
from dash.dependencies import Input, Output,State
import dash_table
from sklearn.linear_model import LinearRegression
import calendar


# Read the data into a pandas DataFrame
data = pd.read_csv('Goa_New1 (1).csv')


# Create a color scale for stations
color_scale = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']

# Convert rainfall columns to numeric and handle non-numeric values as NaN
rainfall_columns = [str(day) for day in range(1, 367)]
data[rainfall_columns] = data[rainfall_columns].apply(pd.to_numeric, errors='coerce')
def get_top_5_events(data):
    # Melt the data to convert the columns for each day to rows
    melted_data = pd.melt(data, id_vars=['Station', 'Year'], value_vars=[str(i) for i in range(1, 367)],
                          var_name='Day', value_name='Rainfall')

    # Convert the 'Day' column to numeric
    melted_data['Day'] = pd.to_numeric(melted_data['Day'])

    # Find the top 5 events with maximum rainfall
    top_5_events = melted_data.nlargest(5, 'Rainfall')

    return top_5_events


# Calculate the total rainfall for each year
total_rainfall_per_year = data.groupby('Year')[rainfall_columns].sum().max(axis=1)

colors = ['rgb(255, 0, 0)', 'rgb(255, 165, 0)', 'rgb(255, 255, 0)', 'rgb(0, 128, 0)']

# Create the Dash app
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP, 'style.css'])


# Suppress the exception for callback components generated by other callbacks
app.config.suppress_callback_exceptions = True

def day_to_date(day):
    date = pd.to_datetime('2022-01-01') + pd.DateOffset(days=int(day) - 1)
    return date.strftime('%d %b')  # Updated date format to '%d %


app.layout = html.Div([
    html.H1("Rainfall Dashboard"),  # Add a title to the dashboard

    # Move the dropdowns above the bar graph
    html.Div([
        html.Div([
            html.Label('Year:', style={'font-weight': 'bold'}),
            dcc.Dropdown(
                id='year-dropdown-bar',
                options=[{'label': str(year), 'value': year} for year in data['Year'].unique()],
                value=data['Year'].min(),
                placeholder='Select Year',
                style={'width': '450px', 'margin-right': '10px'}
            ),
        ], style={'display': 'inline-block', 'margin-right': '20px'}),

        html.Div([
            html.Label('District:', style={'font-weight': 'bold'}),
            dcc.Dropdown(
                id='district-dropdown-bar',
                options=[{'label': district, 'value': district} for district in data['District'].unique()],
                value=data['District'].unique()[0],
                placeholder='Select a District',
                style={'width': '450px', 'margin-right': '10px'}
            ),
        ], style={'display': 'inline-block', 'margin-right': '20px'}),

        html.Div([
            html.Label('Station:', style={'font-weight': 'bold'}),
            dcc.Dropdown(
                id='station-dropdown-tab',
                options=[{'label': station, 'value': station} for station in data['Station'].unique()],
                placeholder='PANJIM-',
                searchable=True,
                style={'width': '480px'}
            ),
        ], style={'display': 'inline-block'}),

    ], style={'display': 'flex', 'margin-bottom': '20px', 'margin-top': '20px'}),





    # Create a navigation bar using Tabs component
        dcc.Tabs(id='tabs', value='tab-1', children=[
            dcc.Tab(label='bar-graph', value='tab-1'),
            dcc.Tab(label='pie-chart', value='tab-2'),
            dcc.Tab(label='rainfall-trend', value='tab-3'),
            dcc.Tab(label='rainfall-bar-chart', value='tab-4'),
            dcc.Tab(label='calendar-heatmap', value='tab-5'),
            dcc.Tab(label='Weekly-calendar-heatmap', value='tab-6'),
            dcc.Tab(label='New Dashboard', value='new-dashboard-tab')
        ]),

        # Create a div to display the content of the selected tab
        html.Div(id='tab-content'),


    # Place the dummy-input element here
    dcc.Input(id='dummy-input', style={'display': 'none'}),

    # Remove the empty graph
    html.Div([]),  # Empty Div to remove the empty graph

    html.Div([
        html.H3('Top 5 Maximum Rainfall Events (All-time)'),
        dash_table.DataTable(
            id='top-events-table-1',
            columns=[
                {'name': 'Station', 'id': 'Station'},
                {'name': 'Year', 'id': 'Year'},
                {'name': 'Day', 'id': 'Day'},
                {'name': 'Rainfall (mm)', 'id': 'Rainfall (mm)'},
            ],
            style_table={'height': '300px', 'overflowY': 'auto'},
            style_header={'fontWeight': 'bold'},
            style_cell={'textAlign': 'left'},
        )
    ], style={'width': '30%', 'display': 'inline-block', 'vertical-align': 'top'}),



    html.Div([
         html.H3('Pie Chart for Total Rainfall'),
        dcc.Graph(id='pie-chart', style={'height':'300px'}),
    ], style={'width': '60%', 'display': 'inline-block', 'vertical-align': 'top', 'margin-left': '20px','margin-bottom':'5px'}),




    html.Div([
        html.Div([
            dcc.Graph(id='rainfall-trend')
        ])
    ]),
    html.Div([
        html.Div([
        html.H3('Total Rainfall histogram for Each Station Over Years',style={'margin-top': '60px','text-align': 'center'}),
            dcc.Dropdown(
               id='district-dropdown',
               options=[{'label': district, 'value': district} for district in data['District'].unique()],
               value=data['District'].unique()[0],
               style={'width': '100%','margin-bottom': '20px','margin-top': '20px'}
    ),
    dcc.Graph(id='rainfall-bar-chart'),
    html.Div(id='top-years-table', style={'width': '50%','margin-bottom': '20px','margin-top': '20px'})
])
]),

  #
    html.Div([
        html.Div(
            dcc.Dropdown(
                id='station-dropdown',
                options=[{'label': station, 'value': station} for station in data['Station'].unique()],
                placeholder='Select a station',
                searchable=True
            ),
            style={'width': '100%', 'margin-bottom': '20px'}
        ),

    html.Div([
        html.Button('Average Rainfall', id='average-rainfall-button', n_clicks=0, style={'width': '300px','height':'40px', 'margin-right': '10px'}),
        html.Button('Total Rainfall', id='total-rainfall-button', n_clicks=0, style={'width': '300px','height':'40px'})
    ], style={'text-align': 'center', 'margin-top': '10px'}),


        html.Div(
            dcc.Graph(id='calendar-heatmap'),
            style={'width': '100%', 'height': '400px', 'margin-bottom': '20px'}
        )
    ], style={'display': 'flex', 'flex-direction': 'column', 'align-items': 'center'}),
    html.Div(id='top-months-table',style={'width':'50%','align-items': 'center'}),
    html.Div(id='top-months-table-all-time',style={'width':'50%','align-items': 'center'}),


    html.Div([
        html.Div(
            dcc.Dropdown(
                id='station-dropdown-weekly',
                options=[{'label': station, 'value': station} for station in data['Station'].unique()],
                placeholder='Select a station',
                searchable=True
            ),
            style={'width': '100%', 'margin-bottom': '20px'}
        ),
        html.Div(
            dcc.Graph(id='Weekly-calendar-heatmap'),
            style={'width': '100%', 'height': '400px', 'margin-bottom': '20px'}
        )
    ], style={'display': 'flex', 'flex-direction': 'column', 'align-items': 'center'}),




])



@app.callback(
    Output('tab-content', 'children'),
    Input('tabs', 'value')
)
def render_content(selected_tab):
    if selected_tab == 'tab-1':
        return dcc.Graph(id='bar-graph', figure={})
    elif selected_tab == 'tab-2':
        return dcc.Graph(id='pie-chart', figure={})
    elif selected_tab == 'tab-3':
        return dcc.Graph(id='rainfall-trend', figure={})
    elif selected_tab == 'tab-4':
        return html.Div([
            dcc.Dropdown(id='district-dropdown'),
            dcc.Graph(id='rainfall-bar-chart'),
        ])
    elif selected_tab == 'tab-5':
        return html.Div([
            dcc.Dropdown(id='station-dropdown'),
            dcc.Graph(id='calendar-heatmap'),
        ])
    elif selected_tab == 'tab-6':
        return html.Div([
            dcc.Dropdown(id='station-dropdown-weekly'),
            dcc.Graph(id='Weekly-calendar-heatmap'),
        ])


# Step 2: Replace 0 values with NaN
data.iloc[:, 9:] = data.iloc[:, 9:].replace(0, float('nan'))

# Step 3: Calculate total rainfall per year
total_rainfall_per_year = data.groupby('Year').sum(numeric_only=True).reset_index()
total_rainfall_per_year['Total_Rainfall'] = total_rainfall_per_year.iloc[:, 9:].sum(axis=1, skipna=True)

# Convert the total rainfall values to millimeters (mm)
total_rainfall_per_year['Total_Rainfall'] = total_rainfall_per_year['Total_Rainfall'] / 10



# Step 6: Define the callback function to update the graph
@app.callback(
    dash.dependencies.Output('rainfall-trend', 'figure'),
    [dash.dependencies.Input('rainfall-trend', 'hoverData')]
)
def update_graph(hoverData):
    # Create a scatter plot for the data points
    trace_scatter = go.Scatter(
        x=total_rainfall_per_year['Year'],
        y=total_rainfall_per_year['Total_Rainfall'],
        mode='markers',
        marker=dict(color='green'),
        name='Total Rainfall',
        hovertemplate='Year: %{x}<br>Total Rainfall: %{y:.0f} mm'
    )

    # Create the trendline using a scatter plot
    trendline_data = total_rainfall_per_year.sort_values(by='Year')
    trace_trendline = go.Scatter(
        x=trendline_data['Year'],
        y=trendline_data['Total_Rainfall'],
        mode='lines+markers',
        marker=dict(color='green'),
        line=dict(color='green'),
        name='Trendline',
        hovertemplate='Year: %{x}<br>Total Rainfall: %{y:.0f} mm'
    )

    # Create the regression line using the linear regression model
    X = total_rainfall_per_year['Year'].values.reshape(-1, 1)
    y = total_rainfall_per_year['Total_Rainfall'].values
    regression_model = LinearRegression()
    regression_model.fit(X, y)
    regression_line = regression_model.predict(X)

    trace_regression_line = go.Scatter(
        x=total_rainfall_per_year['Year'],
        y=regression_line,
        mode='lines',
        line=dict(color='red'),
        name='Regression Line',
        hovertemplate='Year: %{x}<br>Total Rainfall: %{y:.0f} mm'
    )

    layout = go.Layout(
        title='Total Rainfall per Year with Trendline and Regression Line',
        xaxis=dict(title='Year', type='category', tickmode='array', tickvals=total_rainfall_per_year['Year']),
        yaxis=dict(title='Total Rainfall (mm)', tickformat=','),
        hovermode='closest'
    )

    return {'data': [trace_scatter, trace_trendline, trace_regression_line], 'layout': layout}






# Define the callback function for the DataTable
@app.callback(
    Output('top-events-table', 'data'),
    [Input('dummy-input', 'value')]  # Add a dummy input element
)
def update_top_events_table(dummy_value):
    top_5_events = get_top_5_events(data)  # Use the entire dataset



    top_5_events['Rainfall (mm)'] = top_5_events['Rainfall'].apply(lambda x: '{:.0f}'.format(x))  # Updated format

    # Convert the DataFrame to a list of dictionaries for DataTable
    top_events_table = top_5_events.to_dict('records')

    return top_events_table




# Define the callback function for the bar graph
@app.callback(
    Output('bar-graph', 'figure'),
    [Input('year-dropdown-bar', 'value'),
     Input('district-dropdown-bar', 'value')]
)
def update_graph(year, district):
    if pd.isna(year):
        # If the year selected is NaN, show data for all years (include NaN years)
        filtered_data = data[data['District'] == district]
        title = f'Rainfall Range for {district} - All Years'
    else:
        filtered_data = data[(data['Year'] == year) & (data['District'] == district)]
        title = f'Rainfall Range for {district} - {year}'

    grouped_data = filtered_data.groupby('Station')

    # Create a list to store data for the bar chart
    chart_data = []

    for station, (_, station_data) in zip(grouped_data.groups.keys(), grouped_data):
        y_values_flat = station_data[rainfall_columns].mean().apply(pd.to_numeric, errors='coerce').tolist()
        y_values_flat = [0 if pd.isna(value) else value for value in y_values_flat]       #filling o with nan
        day_labels = [day_to_date(day) for day in rainfall_columns]
        chart_data.extend(list(zip([station] * len(day_labels), day_labels, y_values_flat)))

    # Create a DataFrame from the list of data for the bar chart
    df = pd.DataFrame(chart_data, columns=['Station', 'Day', 'Rainfall'])

    # Check if the selected year is NaN
    if pd.isna(year):
        # Add data for NaN year to the DataFrame
        nan_year_data = data[data['Year'].isna() & (data['District'] == district)]
        nan_year_values = nan_year_data[rainfall_columns].mean().apply(pd.to_numeric, errors='coerce').tolist()
        nan_year_day_labels = [day_to_date(day) for day in rainfall_columns]
        df = pd.concat([df, pd.DataFrame({'Station': [station] * len(nan_year_day_labels),
                                          'Day': nan_year_day_labels,
                                          'Rainfall': nan_year_values})])

    fig = px.bar(df, x='Station', y='Rainfall', color='Station',
                 labels={'Station': 'Station', 'Rainfall': 'Rainfall'},
                 title=title,
                 color_continuous_scale='jet',
                 height=500)

    # Map day values to day labels for hover information
    day_mapping = {day: day_to_date(day) for day in rainfall_columns}  # Create day_mapping here
    fig.update_layout(hovermode='closest')

    hovertemplate = '<b>Station:</b> %{x}<br><b>Date:</b> %{customdata}<br><b>Rainfall:</b> %{y:.2f}'  # Corrected hovertemplate
    fig.update_traces(hovertemplate=hovertemplate,
                      customdata=df['Day'])  # Corrected customdata

    # Find the top events (maximum rainfall values) for each station
    top_events_data = []
    for station, (_, station_data) in zip(df['Station'].unique(), df.groupby('Station')):
        max_rainfall_day = station_data['Day'][station_data['Rainfall'].idxmax(skipna=True)]  # Use skipna=True to ignore NaN values
        max_rainfall_value = station_data['Rainfall'].max(skipna=True)  # Use skipna=True to ignore NaN values
        top_events_data.append({'Station': station, 'Day': max_rainfall_day, 'Rainfall': max_rainfall_value})

    # Create a DataFrame with the top events data
    top_events_df = pd.DataFrame(top_events_data)

    # Sort the top events DataFrame by rainfall value in descending order
    top_events_df = top_events_df.sort_values(by='Rainfall', ascending=False)

    # Create annotations for the top events on the right side of the bar graph
    annotations = []
    max_rainfall_value = df['Rainfall'].max() * 1.02  # Set the maximum value for the annotations
    for index, row in top_events_df.iterrows():
        station = row['Station']
        max_rainfall_day = row['Day']
        max_rainfall_value = row['Rainfall']
        annotation_text = f'<b>Top Event</b><br>{station}<br>Date:{max_rainfall_day}<br>Rainfall: {max_rainfall_value:.2f} mm'
        annotations.append(dict(
            x=station,  # Position the annotation above each station
            y=1500,
            xref='x',
            yref='y',
            text=annotation_text,
            showarrow=True,
            arrowhead=3,
            arrowsize=2,
            arrowwidth=1,
            arrowcolor='black',
            ax=0,
            ay=-30,  # Shift the annotation upwards
            bgcolor='rgba(255, 255, 255, 0.8)',
            bordercolor='rgba(0, 0, 0, 0.5)',
            borderwidth=1,
            width=130,
            height=60,
            align='left',
        ))

    fig.update_layout(annotations=annotations)

    return fig








# Define the callback function for the pie chart
@app.callback(
    Output('pie-chart', 'figure'),
    [Input('year-dropdown-bar', 'value'),
     Input('district-dropdown-bar', 'value')]
)
def update_graph(year, district):
    filtered_data = data[(data['Year'] == year) & (data['District'] == district)]
    grouped_data = filtered_data.groupby('Station')[rainfall_columns].sum().reset_index()

    fig = go.Figure(go.Sunburst(
        labels=grouped_data['Station'],
        parents=[""] * len(grouped_data['Station']),  # Set all parents as empty to create a single-level sunburst
        values=grouped_data[rainfall_columns[1:]].sum(axis=1),
        branchvalues="total",  # Use 'total' to show the total value at the center of the sunburst
        marker=dict(colors=['gold', 'mediumturquoise', 'darkorange', 'lightgreen']),  # Set custom colors
        hovertemplate="Station: %{label}<br>Rainfall: %{value:.0f}<extra></extra>",  # Custom hover template
    ))

    fig.update_layout(margin=dict(t=0, l=0, r=0, b=0))  # Remove unnecessary margins

    return fig

# Function to get top 5 maximum rainfall events for each station
def get_top_5_station_events(data):
    top_events = []
    for station in data['Station'].unique():
        station_data = data[data['Station'] == station]  # Remove the drop operation
        top_events.append(station_data.apply(lambda row: sorted(row)[-5:], axis=0).stack())
    return pd.concat(top_events, axis=1)


# Define the callback function to update the heatmap based on the selected district and station
@app.callback(
    Output('calendar-heatmap', 'figure'),
    [Input('station-dropdown', 'value'),
     Input('station-dropdown-tab', 'value'),
     Input('total-rainfall-button', 'n_clicks'),
     Input('average-rainfall-button', 'n_clicks')],
    [State('calendar-heatmap', 'figure')]

)


def update_heatmap(selected_station_tab,selected_station, total_clicks, average_clicks, figure):
    # Filter data for the selected district and station
    if selected_station_tab is not None:
        selected_station= selected_station_tab


    if selected_station is None:
        # If no station is selected, show the heatmap for the first station
        selected_station = data['Station'].unique()[0]
    filtered_data = data[(data['Station'] == selected_station)]
    ctx = dash.callback_context
    button_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # Filter data for the selected district and station
    filtered_data = data[(data['Station'] == selected_station)]

    # Reshape the data for heatmap
    melted_data = pd.melt(filtered_data, id_vars=['Year'], value_vars=[str(i) for i in range(1, 367)],
                          var_name='Day', value_name='Rainfall')

    # Convert Day column to numeric
    melted_data['Day'] = pd.to_numeric(melted_data['Day'])

    # Calculate the weekly differences of days
    melted_data['Week'] = (melted_data['Day'] - 1) // 7 + 1

    # Calculate the month from the 'Day' column
    melted_data['Month'] = melted_data['Day'].apply(
        lambda day: (pd.to_datetime('2022-01-01') + pd.to_timedelta(day - 1, unit='D')).month)

    if button_id == 'total-rainfall-button':
        rainfall_calculation = melted_data.groupby(['Year', 'Month'])['Rainfall'].sum().reset_index()
    else:
        rainfall_calculation = melted_data.groupby(['Year', 'Month'])['Rainfall'].mean().reset_index()

    custom_colorscale = [[0, 'rgb(255, 255, 255)'],  # 0 mm (white)
                         [0.01, 'rgb(0, 0, 128)'],  # 0.01 mm to 0.5 mm (dark blue)
                         [0.25, 'rgb(0, 0, 255)'],  # 0.25 mm to 2.5 mm (blue)
                         [1.0, 'rgb(173, 216, 230)']]  # 1 mm and above (light blue)

    fig = go.Figure(go.Heatmap(x=rainfall_calculation['Month'], y=rainfall_calculation['Year'],
                               z=rainfall_calculation['Rainfall'],
                               colorscale=custom_colorscale, colorbar_title='Rainfall'))

    fig.update_layout(title=f'Rainfall Monthly Calendar for Station: {selected_station}',
                      xaxis_title='Months',
                      yaxis_title='Year',
                      xaxis=dict(tickvals=list(range(1, 13)),
                                 ticktext=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov',
                                           'Dec']),
                      yaxis=dict(autorange='reversed'))

    # Create custom hovertemplate
    hovertemplate = 'Year: %{y}<br>Month: %{customdata}<br>Rainfall: %{z:.0f} mm<br>'
    fig.update_traces(hovertemplate=hovertemplate,
                      customdata=[month for month in rainfall_calculation['Month']])

    hovertext = []
    for year, month, rainfall in zip(rainfall_calculation['Year'], rainfall_calculation['Month'],
                                     rainfall_calculation['Rainfall']):
        if pd.notna(rainfall):
            hovertext.append(f'Year: {year}<br>Month: {month}<br>Rainfall: {rainfall} mm')
        else:
            hovertext.append(f'Year: {year}<br>Month: {month}<br>Rainfall: NaN')
    fig.data[0].hovertext = hovertext

    return fig


@app.callback(
    Output('top-months-table', 'children'),
    [Input('station-dropdown', 'value')]
)
def update_top_months_table(selected_station):
    # Filter data for the selected station
    if selected_station is None:
        selected_station = data['Station'].unique()[0]  # Set the default station to the first station
    filtered_data = data[(data['Station'] == selected_station)]

    # Reshape the data for heatmap
    melted_data = pd.melt(filtered_data, id_vars=['Year'], value_vars=[str(i) for i in range(1, 367)],
                          var_name='Day', value_name='Rainfall')

    # Convert Day column to numeric
    melted_data['Day'] = pd.to_numeric(melted_data['Day'])

    # Calculate the month from the 'Day' column
    melted_data['Month'] = melted_data['Day'].apply(
        lambda day: (pd.to_datetime('2022-01-01') + pd.to_timedelta(day - 1, unit='D')).month)
    monthly_rainfall = melted_data.groupby(['Year', 'Month'])['Rainfall'].sum().reset_index()

    # Get the top 5 months with the maximum total rainfall for each year
    top_months_per_year = monthly_rainfall.loc[monthly_rainfall.groupby('Year')['Rainfall'].idxmax()]
    top_months_per_year = top_months_per_year.nlargest(5, 'Rainfall')



    # Format the "Rainfall" and "Average Rainfall" columns to remove decimal points
    top_months_per_year['Rainfall'] = top_months_per_year['Rainfall'].apply(lambda x: '{:.0f}'.format(x))


    # Create the table using dash_table.DataTable
    table = dash_table.DataTable(
        id='top-months-datatable',
        columns=[
            {'name': 'Year', 'id': 'Year'},
            {'name': 'Month', 'id': 'Month'},
            {'name': 'Total Rainfall (mm)', 'id': 'Rainfall'},

        ],
        data=top_months_per_year.to_dict('records')
    )

    return table




# Define the callback function to update the top months table
@app.callback(
    Output('top-months-table-all-time', 'children'),
    [Input('calendar-heatmap', 'figure')]
)
def update_top_months_table(figure):
    # Extract data from the figure to get the monthly total rainfall
    monthly_rainfall = figure['data'][0]['z']

    # Create a DataFrame for monthly total rainfall
    monthly_rainfall_df = pd.DataFrame({'Month': list(range(1, 13)), 'Total_Rainfall': monthly_rainfall})

    # Get the top 5 months with the highest total rainfall
    top_months = monthly_rainfall_df.nlargest(5, 'Total_Rainfall')

   # Calculate the average rainfall for each month
    average_rainfall = monthly_rainfall_df['Total_Rainfall'].mean()

    # Create the table using dash_table.DataTable
    table = html.Table([
        html.Thead(html.Tr([html.Th('Month'), html.Th('Total Rainfall (mm)'), html.Th('Average Rainfall (mm)')])),
        html.Tbody([
            html.Tr([html.Td(month), html.Td(str(int(rainfall))), html.Td(f'{average_rainfall:.2f}')])
            for month, rainfall in top_months[['Month', 'Total_Rainfall']].values
        ])
    ])

    return table


@app.callback(
    Output('Weekly-calendar-heatmap', 'figure'),
    [Input('station-dropdown-weekly', 'value'),
     Input('station-dropdown-tab', 'value')]
)
def update_heatmap(selected_station_tab,selected_station):
    # Filter data for the selected district and station
    if selected_station_tab is not None:
        selected_station = selected_station_tab
    if selected_station is None:
        # If no station is selected, show the heatmap for the first station
        selected_station = data['Station'].unique()[0]

    # Filter data for the selected station
    filtered_data = data[data['Station'] == selected_station]

# Reshape the data for heatmap
    melted_data = pd.melt(filtered_data, id_vars=['Year'], value_vars=[str(i) for i in range(1, 367)],
                          var_name='Day', value_name='Rainfall')

    # Convert Day column to numeric
    melted_data['Day'] = pd.to_numeric(melted_data['Day'])

    # Calculate the weekly differences of days
    melted_data['Week'] = (melted_data['Day'] - 1) // 7 + 1

    # Calculate the weekly sum of rainfall for each year and week
    weekly_rainfall = melted_data.groupby(['Year', 'Week'], as_index=False)['Rainfall'].sum()

    custom_colorscale = [[0, 'rgb(255, 255, 255)'],  # 0 mm (white)
                         [0.01, 'rgb(0, 0, 128)'],  # 0.01 mm to 0.5 mm (dark blue)
                         [0.25, 'rgb(0, 0, 255)'],  # 0.25 mm to 2.5 mm (blue)
                         [1.0, 'rgb(173, 216, 230)']]  # 1 mm and above (light blue)

    fig = go.Figure(go.Heatmap(x=weekly_rainfall['Week'], y=weekly_rainfall['Year'], z=weekly_rainfall['Rainfall'],
                               colorscale=custom_colorscale, colorbar_title='Rainfall'))

    fig.update_layout(title=f'Rainfall Weekly Calendar for  Station: {selected_station}',
                      xaxis_title='Weeks',
                      yaxis_title='Year',
                      xaxis=dict(nticks=52),
                      yaxis=dict(autorange='reversed'))



    # Create custom hovertemplate with week, year, and rainfall info
    hovertemplate = 'Week: %{x}<br>Year: %{y}<br>Sum of Rainfall: %{z:.0f} mm'  # Format rainfall as integer
    fig.update_traces(hovertemplate=hovertemplate)


    # Update hovertemplate to show "0" for cells with no rainfall and "NaN" for cells where data is not available
    hovertext = []
    for week, year, rainfall in zip(weekly_rainfall['Week'], weekly_rainfall['Year'], weekly_rainfall['Rainfall']):
        hovertext.append(f'Week: {week}<br>Year: {year}<br>Rainfall: {rainfall} mm' if pd.notna(rainfall) else f'Week: {week}<br>Year: {year}<br>Rainfall: NaN')
    fig.data[0].hovertext = hovertext

    return fig

@app.callback(
    Output('top-years-table-1', 'children'),
    [Input('rainfall-bar-chart', 'figure')]
)
def update_top_years_table(figure):
    # Combine data from both districts
    combined_data = data[data['District'].isin(['NORTH GOA', 'SOUTH GOA'])]

    # Group data by Year and calculate total rainfall
    grouped_data = combined_data.groupby(['Year', 'District'])[rainfall_columns].sum().reset_index()

    # Calculate total rainfall for each year
    year_total_rainfall = grouped_data[rainfall_columns].sum(axis=1)

    # Create a DataFrame to hold the year-wise total rainfall and district
    year_rainfall_df = pd.DataFrame({
        'Year': grouped_data['Year'],
        'District': grouped_data['District'],
        'Total_Rainfall': year_total_rainfall
    })

    # Get the top 5 years with the maximum total rainfall
    top_years = year_rainfall_df.nlargest(5, 'Total_Rainfall')

    # Format the 'Total Rainfall' column to display integers
    top_years['Total_Rainfall'] = top_years['Total_Rainfall'].astype(int)

    # Create the table using dash_table.DataTable
    table = dash_table.DataTable(
        id='top-years-datatable',
        columns=[
            {'name': 'Year', 'id': 'Year'},
            {'name': 'District', 'id': 'District'},
            {'name': 'Total Rainfall (mm)', 'id': 'Total_Rainfall'}
        ],
        data=top_years.to_dict('records'),
        style_cell={'textAlign': 'center'}  # Center-align cell content
    )

    return table



# Define the callback function for the rainfall bar chart
@app.callback(
    Output('rainfall-bar-chart', 'figure'),
    [Input('district-dropdown', 'value'),
     Input('district-dropdown-bar', 'value')],
)
def update_bar_chart(selected_district_bar, selected_district):
    if selected_district_bar is not None:
        selected_district = selected_district_bar
    filtered_data = data[data['District'] == selected_district]

    # Group data by Year and Station and calculate total rainfall
    grouped_data = filtered_data.groupby(['Year', 'Station'])[rainfall_columns].sum().reset_index()

    # Create the bar chart
    fig = go.Figure()

    for i, station in enumerate(grouped_data['Station'].unique()):
        station_data = grouped_data[grouped_data['Station'] == station]
        fig.add_trace(go.Bar(
            x=station_data['Year'],
            y=station_data[rainfall_columns].sum(axis=1),
            name=station,
            marker_color=color_scale[i % len(color_scale)],
            hovertemplate='Year: %{x}<br>Total Rainfall: %{y} mm',
            customdata=[[station] * len(station_data['Year'])]  # Provide custom data for station name
        ))

    fig.update_layout(title=f'Total Rainfall for Each Station Over Years in {selected_district} District',
                      xaxis_title='Year',
                      yaxis_title='Total Rainfall (mm)',
                      barmode='group',  # Group bars for each year
                      margin=dict(t=50, l=0, r=0, b=30),
                      xaxis_tickangle=-45,  # Rotate x-axis labels for better visibility
                      xaxis_tickmode='linear',  # Ensure linear spacing of x-axis ticks
                      xaxis_dtick=1  # Set the interval between x-axis ticks to 1 year
                      )

    return fig


if __name__ == '__main__':
    app.run_server(debug=True)
